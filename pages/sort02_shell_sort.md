
## 希尔排序

希尔排序是希尔于1959年提出的一种排序算法。该方法首先对彼此相距很远的元素对进行排序，然后逐渐减小要比较的元素之间的差距。

希尔排序是对直接插入排序优化。

Shellsort 的运行时间很大程度上取决于它使用的间隙(gap)序列。

希尔排序的基本原理：

1. 先生成 gap 序列，一般 gap1 = length/2，gap2 = gap1/2 ... 知道 gap = 1
2. 有了 gap 之后，将待排序的列表分成若干个分组，`arr[index], arr[index+gap*1]，arr[index+gap*2],... arr[index+gap*n]` 为同一组
3. 然后对每个分组，进行插入排序

希尔排序时间复杂度为，不好给出具体的数，因为希尔排序时间在于 gap 的取值，计算出最优 gap，目前并没有最优的算法。

如果 gap 序列为： length/2, length/4 ,..., 1，那么希尔排序的时间复杂度为 O(n^2)

如果 gap 序列为：2(length/4)+1,...,3,1，那么希尔排序的时间复杂度为 O(n^1.5)

更多关于希尔时间复杂度的介绍可以查看 [wiki/Shellsort](https://en.wikipedia.org/wiki/Shellsort)

希尔排序是不稳定的（判断排序算法是否稳定，在于相同的元素，在排序后，他们先后顺序是否发生变化，在希尔排序中，两个相同的元素，他们可能被划分到不同的分组，最后他们两的先后顺序可能会发生变化）。


例如：`[2, 3, 6, 1, 8, 7, 4, 9, 0, 5]`，排序逻辑如下：

```
// [2, 3, 6, 1, 8, 7, 4, 9, 0, 5]
// gap1 = 10/2 = 5 共5组
// 分组逻辑：(arr[index], arr[index+gap*1]，arr[index+gap*2])
// 注意：分组并不是产生多个数组，而是逻辑上将其划分为一组
// [2,7],[3,4],[6,9],[1,0],[8,5]
// 分别对上面分组进行插入排序
// [2, 3, 6, 0, 5, 7, 4, 9, 1, 8]
// gap2 = 5/2 = 2 共2组
// [2,6,5,4,1],[3,0,7,9,8]
// [1, 0, 2, 3, 4, 7, 5, 8, 6, 9]
// gap3 = 1/2 = 1
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]```
```

实现代码：

```
public void sort(int[] arr) {
    //初始 gap，默认设置为数组长度的一半
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        System.out.println("----gap=" + gap);
        //从第 gap 个元素开始对相同的组进行直接插入排序操作
        for (int i = gap; i < arr.length; i++) {
            int current = arr[i];
            int j;
            // 从后往前扫描
            for (j = i; j > 0; j -= gap) {
                // current 和前面第 gap 个元素对比（和直接插入排序类似，只不过直接插入排序的gap=1）
                if (j - gap < 0 || current >= arr[j - gap]) break;
                arr[j] = arr[j - gap];
            }
            arr[j] = current;
        }
    }
    // 总结：从上可以看出，希尔排序和直接插入排序代码很类似，直接插入排序是 j-1, 希尔排序时 j-gap, 可以将直接插入排序的 gap 看做 1
    // 然后在直接插入排序的外层加上 gap 循环，就成了希尔排序
}
```
